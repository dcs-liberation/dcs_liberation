from __future__ import annotations

import copy
import itertools
import logging
from dataclasses import dataclass, field
from typing import Optional, Dict, Type, List, Any, Iterator, TYPE_CHECKING

import dcs
from dcs.countries import country_dict
from dcs.unittype import ShipType

from game.data.building_data import (
    WW2_ALLIES_BUILDINGS,
    DEFAULT_AVAILABLE_BUILDINGS,
    WW2_GERMANY_BUILDINGS,
    WW2_FREE,
)
from game.data.doctrine import (
    Doctrine,
    MODERN_DOCTRINE,
    COLDWAR_DOCTRINE,
    WWII_DOCTRINE,
)
from game.data.unitclass import UnitClass
from game import db
from game.dcs.aircrafttype import AircraftType
from game.dcs.groundunittype import GroundUnitType
from game.dcs.shipunittype import ShipUnitType
from game.dcs.unitset import UnitSet
from game.dcs.unittype import UnitType
from gen.templates import (
    GroundObjectTemplates,
    TemplateCategory,
    GroupTemplate,
    GroundObjectTemplate,
)

if TYPE_CHECKING:
    from game.theater.start_generator import ModSettings


@dataclass
class Faction:
    #: List of locales to use when generating random names. If not set, Faker will
    #: choose the default locale.
    locales: Optional[List[str]]

    # Country used by this faction
    country: str = field(default="")

    # Nice name of the faction
    name: str = field(default="")

    # List of faction file authors
    authors: str = field(default="")

    # A description of the faction
    description: str = field(default="")

    # Available aircraft
    aircrafts: List[AircraftType] = field(default_factory=list)

    # Available awacs aircraft
    awacs: List[AircraftType] = field(default_factory=list)

    # Available tanker aircraft
    tankers: List[AircraftType] = field(default_factory=list)

    # Available frontline units
    frontline_units: List[GroundUnitType] = field(default_factory=list)

    # Available artillery units
    artillery_units: List[GroundUnitType] = field(default_factory=list)

    # Infantry units used
    infantry_units: List[GroundUnitType] = field(default_factory=list)

    # Logistics units used
    logistics_units: List[GroundUnitType] = field(default_factory=list)

    # Possible Air Defence units, Like EWRs
    air_defense_units: List[GroundUnitType] = field(default_factory=list)

    # A list of all supported sets of units
    unit_sets: list[UnitSet] = field(default_factory=list)

    # TODO Legacy generators
    # Possible SAMS site generators for this faction
    air_defenses: List[str] = field(default_factory=list)

    # Possible Missile site generators for this faction
    missiles: List[str] = field(default_factory=list)

    # Possible costal site generators for this faction
    coastal_defenses: List[str] = field(default_factory=list)

    # Required mods or asset packs
    requirements: Dict[str, str] = field(default_factory=dict)

    # possible aircraft carrier units
    aircraft_carrier: List[ShipUnitType] = field(default_factory=list)

    # possible helicopter carrier units
    helicopter_carrier: List[ShipUnitType] = field(default_factory=list)

    # Possible carrier names
    carrier_names: List[str] = field(default_factory=list)

    # Possible helicopter carrier names
    helicopter_carrier_names: List[str] = field(default_factory=list)

    # Navy group generators
    navy_generators: List[str] = field(default_factory=list)

    # Available destroyers
    destroyers: List[ShipUnitType] = field(default_factory=list)

    # Available cruisers
    cruisers: List[ShipUnitType] = field(default_factory=list)

    # How many navy group should we try to generate per CP on startup for this faction
    navy_group_count: int = field(default=1)

    # How many missiles group should we try to generate per CP on startup for this faction
    missiles_group_count: int = field(default=1)

    # How many coastal group should we try to generate per CP on startup for this faction
    coastal_group_count: int = field(default=1)

    # Whether this faction has JTAC access
    has_jtac: bool = field(default=False)

    # Unit to use as JTAC for this faction
    jtac_unit: Optional[AircraftType] = field(default=None)

    # doctrine
    doctrine: Doctrine = field(default=MODERN_DOCTRINE)

    # List of available building templates for this faction
    building_set: List[str] = field(default_factory=list)

    # List of default livery overrides
    liveries_overrides: Dict[AircraftType, List[str]] = field(default_factory=dict)

    #: Set to True if the faction should force the "Unrestricted satnav" option
    #: for the mission. This option enables GPS for capable aircraft regardless
    #: of the time period or operator. For example, the CJTF "countries" don't
    #: appear to have GPS capability, so they need this.
    #:
    #: Note that this option cannot be set per-side. If either faction needs it,
    #: both will use it.
    unrestricted_satnav: bool = False

    # All possible templates which can be generated by the faction
    templates: GroundObjectTemplates = field(default=GroundObjectTemplates())

    def __getitem__(self, item: str) -> Any:
        return getattr(self, item)

    @property
    def accessible_units(self) -> Iterator[UnitType[Any]]:
        yield from self.accessible_ground_units
        yield from self.accessible_ships

    @property
    def accessible_ground_units(self) -> Iterator[GroundUnitType]:
        yield from self.ground_units
        yield from self.infantry_units
        yield from self.air_defense_units
        for unit_set in self.unit_sets:
            yield from unit_set.ground_units

    @property
    def accessible_ships(self) -> Iterator[ShipUnitType]:
        yield from self.destroyers
        yield from self.cruisers
        yield from self.helicopter_carrier
        yield from self.aircraft_carrier
        for unit_set in self.unit_sets:
            yield from unit_set.ship_units

    def has_access_to_unit_type(self, unit_type: str) -> bool:
        # GroundUnits
        if any(unit_type == u.dcs_id for u in self.accessible_units):
            return True

        # Statics
        if unit_type in self.building_set or db.static_type_from_name(unit_type):
            # TODO Improve the statics checking
            # dcs type ids as string
            return True
        return False

    def has_access_to_unit_class(self, unit_class: UnitClass) -> bool:
        for vehicle in itertools.chain(self.frontline_units, self.artillery_units):
            if vehicle.unit_class is unit_class:
                return True
        return False

    def has_access_to_template(
        self, template: GroundObjectTemplate, template_category: TemplateCategory
    ) -> bool:
        # New checking for unit_sets and units
        for unit_set in self.unit_sets:
            if template.name in unit_set.templates:
                return True
        # TODO How to check "variants"? Where to define the additional units
        # How should this be working in the future?... Best example is the S-300 stuff.

        # Legacy Checking
        if (
            (
                template_category == TemplateCategory.AirDefence
                and template.template_type == "EWR"
            )
            or (
                # Legacy handling for air defense generators
                template_category == TemplateCategory.AirDefence
                and template.name in self.air_defenses
            )
            or template.name in self.navy_generators
            or template.name in self.missiles
            or template.name in self.coastal_defenses
            or (
                template.template_type in self.building_set + ["fob", "ammo", "factory"]
            )
            or (template.template_type == "carrier" and self.aircraft_carrier)
            or (template.template_type == "lha" and self.helicopter_carrier)
            or template_category == TemplateCategory.Armor
        ):
            return True
        return False

    def load_templates(self, all_templates: GroundObjectTemplates) -> None:
        # This loads all faction possible sam templates and the default ones
        # For legacy reasons this allows to check for template names. This can be
        # improved in the future to have more control about the possible Templates.
        # For example it can be possible to define the unit_types and check if all
        # requirements for the template are fulfilled.
        for category, template in all_templates.templates:
            if self.has_access_to_template(template, category):
                # Make a deep copy of a template and add it to the template_list.
                # This is required to have faction independent templates. Otherwise
                # the reference would be the same and changes would affect all.
                faction_template = copy.deepcopy(template)
                # Initialize the template and the randomizers. This also removes all
                # units which are not accessible by this faction.
                # Empty groups will be removed.
                if template.name not in self.legacy_support:
                    # Only validate already migrated templates
                    faction_template.groups[:] = [
                        group_template
                        for group_template in faction_template.groups
                        if self.initialize_group_template(group_template)
                    ]
                if faction_template.groups:
                    self.templates.add_template(category, faction_template)

    def initialize_group_template(self, group_template: GroupTemplate) -> bool:

        # If template has a randomizer check only the randomization
        if group_template.randomizer:
            return group_template.randomizer.init_randomization_for_faction(self)

        # check for supported units
        supported_units = [
            unit
            for unit in group_template.units
            if self.has_access_to_unit_type(unit.type)
        ]

        if (
            len(supported_units) != len(group_template.units)
            and not group_template.optional
        ):
            logging.warning(
                f"Faction does not support unit from template group {group_template.name}"
            )
            # TODO if optional just skip the units
            return False
        return True

    @classmethod
    def from_json(cls: Type[Faction], json: Dict[str, Any]) -> Faction:
        faction = Faction(locales=json.get("locales"))

        faction.country = json.get("country", "/")
        if faction.country not in [c.name for c in country_dict.values()]:
            raise AssertionError(
                'Faction\'s country ("{}") is not a valid DCS country ID'.format(
                    faction.country
                )
            )

        faction.name = json.get("name", "")
        if not faction.name:
            raise AssertionError("Faction has no valid name")

        faction.authors = json.get("authors", "")
        faction.description = json.get("description", "")

        faction.aircrafts = [AircraftType.named(n) for n in json.get("aircrafts", [])]
        faction.awacs = [AircraftType.named(n) for n in json.get("awacs", [])]
        faction.tankers = [AircraftType.named(n) for n in json.get("tankers", [])]

        faction.aircrafts = list(
            set(faction.aircrafts + faction.awacs + faction.tankers)
        )

        faction.frontline_units = [
            GroundUnitType.named(n) for n in json.get("frontline_units", [])
        ]
        faction.artillery_units = [
            GroundUnitType.named(n) for n in json.get("artillery_units", [])
        ]
        faction.infantry_units = [
            GroundUnitType.named(n) for n in json.get("infantry_units", [])
        ]
        faction.logistics_units = [
            GroundUnitType.named(n) for n in json.get("logistics_units", [])
        ]
        faction.air_defense_units = [
            GroundUnitType.named(n) for n in json.get("air_defense_units", [])
        ]

        faction.unit_sets = [UnitSet.named(n) for n in json.get("unit_sets", [])]

        # Compatibility for legacy generators
        faction.air_defenses = json.get("air_defenses", [])
        faction.missiles = json.get("missiles", [])
        faction.coastal_defenses = json.get("coastal_defenses", [])
        faction.navy_generators = json.get("navy_generators", [])

        faction.requirements = json.get("requirements", {})

        faction.carrier_names = json.get("carrier_names", [])
        faction.helicopter_carrier_names = json.get("helicopter_carrier_names", [])

        faction.aircraft_carrier = [
            ShipUnitType.named(n) for n in json.get("aircraft_carrier", [])
        ]
        faction.helicopter_carrier = [
            ShipUnitType.named(n) for n in json.get("helicopter_carrier", [])
        ]
        faction.destroyers = [ShipUnitType.named(n) for n in json.get("destroyers", [])]
        faction.cruisers = [ShipUnitType.named(n) for n in json.get("cruisers", [])]

        faction.has_jtac = json.get("has_jtac", False)
        jtac_name = json.get("jtac_unit", None)
        if jtac_name is not None:
            faction.jtac_unit = AircraftType.named(jtac_name)
        else:
            faction.jtac_unit = None
        faction.navy_group_count = int(json.get("navy_group_count", 1))
        faction.missiles_group_count = int(json.get("missiles_group_count", 0))
        faction.coastal_group_count = int(json.get("coastal_group_count", 0))

        # Load doctrine
        doctrine = json.get("doctrine", "modern")
        if doctrine == "modern":
            faction.doctrine = MODERN_DOCTRINE
        elif doctrine == "coldwar":
            faction.doctrine = COLDWAR_DOCTRINE
        elif doctrine == "ww2":
            faction.doctrine = WWII_DOCTRINE
        else:
            faction.doctrine = MODERN_DOCTRINE

        # Load the building set
        building_set = json.get("building_set", "default")
        if building_set == "default":
            faction.building_set = DEFAULT_AVAILABLE_BUILDINGS
        elif building_set == "ww2free":
            faction.building_set = WW2_FREE
        elif building_set == "ww2ally":
            faction.building_set = WW2_ALLIES_BUILDINGS
        elif building_set == "ww2germany":
            faction.building_set = WW2_GERMANY_BUILDINGS
        else:
            faction.building_set = DEFAULT_AVAILABLE_BUILDINGS

        # Load liveries override
        faction.liveries_overrides = {}
        liveries_overrides = json.get("liveries_overrides", {})
        for name, livery in liveries_overrides.items():
            aircraft = AircraftType.named(name)
            faction.liveries_overrides[aircraft] = [s.lower() for s in livery]

        faction.unrestricted_satnav = json.get("unrestricted_satnav", False)

        # Templates
        faction.templates = GroundObjectTemplates()

        return faction

    @property
    def legacy_support(self) -> list[str]:
        return (
            self.air_defenses
            + self.navy_generators
            + self.missiles
            + self.coastal_defenses
        )

    @property
    def ground_units(self) -> Iterator[GroundUnitType]:
        yield from self.artillery_units
        yield from self.frontline_units
        yield from self.logistics_units

    @property
    def ships(self) -> Iterator[GroundUnitType]:
        yield from self.artillery_units
        yield from self.frontline_units
        yield from self.logistics_units

    def infantry_with_class(self, unit_class: UnitClass) -> Iterator[GroundUnitType]:
        for unit in self.infantry_units:
            if unit.unit_class is unit_class:
                yield unit

    def apply_mod_settings(self, mod_settings: ModSettings) -> Faction:
        # aircraft
        if not mod_settings.a4_skyhawk:
            self.remove_aircraft("A-4E-C")
        if not mod_settings.hercules:
            self.remove_aircraft("Hercules")
        if not mod_settings.f22_raptor:
            self.remove_aircraft("F-22A")
        if not mod_settings.f104_starfighter:
            self.remove_aircraft("VSN_F104G")
            self.remove_aircraft("VSN_F104S")
            self.remove_aircraft("VSN_F104S_AG")
        if not mod_settings.jas39_gripen:
            self.remove_aircraft("JAS39Gripen")
            self.remove_aircraft("JAS39Gripen_AG")
        if not mod_settings.su57_felon:
            self.remove_aircraft("Su-57")
        # frenchpack
        if not mod_settings.frenchpack:
            self.remove_vehicle("AMX10RCR")
            self.remove_vehicle("SEPAR")
            self.remove_vehicle("ERC")
            self.remove_vehicle("M120")
            self.remove_vehicle("AA20")
            self.remove_vehicle("TRM2000")
            self.remove_vehicle("TRM2000_Citerne")
            self.remove_vehicle("TRM2000_AA20")
            self.remove_vehicle("TRMMISTRAL")
            self.remove_vehicle("VABH")
            self.remove_vehicle("VAB_RADIO")
            self.remove_vehicle("VAB_50")
            self.remove_vehicle("VIB_VBR")
            self.remove_vehicle("VAB_HOT")
            self.remove_vehicle("VAB_MORTIER")
            self.remove_vehicle("VBL50")
            self.remove_vehicle("VBLANF1")
            self.remove_vehicle("VBL-radio")
            self.remove_vehicle("VBAE")
            self.remove_vehicle("VBAE_MMP")
            self.remove_vehicle("AMX-30B2")
            self.remove_vehicle("Tracma")
            self.remove_vehicle("JTACFP")
            self.remove_vehicle("SHERIDAN")
            self.remove_vehicle("Leclerc_XXI")
            self.remove_vehicle("Toyota_bleu")
            self.remove_vehicle("Toyota_vert")
            self.remove_vehicle("Toyota_desert")
            self.remove_vehicle("Kamikaze")
            self.remove_vehicle("AMX1375")
            self.remove_vehicle("AMX1390")
            self.remove_vehicle("VBCI")
            self.remove_vehicle("T62")
            self.remove_vehicle("T64BV")
            self.remove_vehicle("T72M")
            self.remove_vehicle("KORNET")
        # high digit sams
        if not mod_settings.high_digit_sams:
            self.remove_air_defenses("SA-10B/S-300PS Battery")
            self.remove_air_defenses("SA-12/S-300V Battery")
            self.remove_air_defenses("SA-20/S-300PMU-1 Battery")
            self.remove_air_defenses("SA-20B/S-300PMU-2 Battery")
            self.remove_air_defenses("SA-23/S-300VM Battery")
            self.remove_air_defenses("SA-17 Grizzly Battery")
            self.remove_air_defenses("KS-19 AAA Site")
        return self

    def remove_aircraft(self, name: str) -> None:
        for i in self.aircrafts:
            if i.dcs_unit_type.id == name:
                self.aircrafts.remove(i)

    def remove_air_defenses(self, name: str) -> None:
        for i in self.air_defenses:
            if i == name:
                self.air_defenses.remove(i)

    def remove_vehicle(self, name: str) -> None:
        for i in self.frontline_units:
            if i.dcs_unit_type.id == name:
                self.frontline_units.remove(i)


def load_ship(name: str) -> Optional[Type[ShipType]]:
    if (ship := getattr(dcs.ships, name, None)) is not None:
        return ship
    logging.error(f"FACTION ERROR : Unable to find {name} in dcs.ships")
    return None


def load_all_ships(data: list[str]) -> List[Type[ShipType]]:
    items = []
    for name in data:
        item = load_ship(name)
        if item is not None:
            items.append(item)
    return items
